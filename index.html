<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="UTF-8">
    <title>仙玉奖励计算器</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            background-color: #f0f8ff;
        }

        .calculator {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }

        .input-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            margin-bottom: 10px;
            color: #2c3e50;
            font-size: 18px;
        }

        input[type="number"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #3498db;
            border-radius: 6px;
            font-size: 16px;
            margin-bottom: 15px;
        }

        button {
            background: #3498db;
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }

        button:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .result {
            margin-top: 30px;
            padding: 20px;
            background: #e8f4f8;
            border-radius: 8px;
            display: none;
        }

        .result h3 {
            color: #2c3e50;
            margin-bottom: 15px;
        }

        .jade-total {
            font-size: 24px;
            color: #e74c3c;
            font-weight: bold;
            margin: 15px 0;
        }

        .calculation-steps {
            background: white;
            padding: 15px;
            border-radius: 6px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="calculator">
        <h2>关卡仙玉计算器</h2>
        
        <div class="input-group">
            <label for="start">起始关卡：</label>
            <input type="number" id="start" min="1" step="1" placeholder="开始关卡">
        </div>

        <div class="input-group">
            <label for="end">结束关卡：</label>
            <input type="number" id="end" min="1" step="1" placeholder="结束关卡">
        </div>

        <button onclick="calculateJade()">立即计算</button>

        <div class="result" id="result">
            <h3>计算结果</h3>
            <div class="jade-total">
                总计仙玉：<span id="total-jade">0</span>
            </div>
            <div class="calculation-steps" id="steps">
                <!-- 计算步骤将动态插入到这里 -->
            </div>
        </div>
    </div>

   <script>
    function calculateJade() {
        // 获取输入值
        const start = parseInt(document.getElementById('start').value) || 0;
        const end = parseInt(document.getElementById('end').value) || 0;
        if (start <= 0 || end < start) {
            alert("请输入有效的起始和结束关卡");
            return;
        }

        let total = 0;
        const steps = [];

        
            // 计算基础奖励（非第七关）
            const totalStages = end - start + 1;
            const seventhStagesCount = Math.floor(end / 7) - Math.floor((start - 1) / 7);
            const nonSeventhStages = totalStages - seventhStagesCount;
            const baseReward = nonSeventhStages * 100;
            total += baseReward;
            steps.push(`基础奖励：${nonSeventhStages}关 × 100 = ${baseReward}`);

            // 计算第七关特殊奖励
            const firstSeventh = Math.ceil(start / 7) * 7;
            const lastSeventh = Math.floor(end / 7) * 7;
            let cycleBonus = 0;
            if (firstSeventh <= lastSeventh) {
                for (let k = firstSeventh / 7; k <= lastSeventh / 7; k++) {
                    const currentStage = k * 7;
                    let bonus;
                    if (currentStage <= 672) {
                        bonus = k * 100 + 400;
                    } else {
                        bonus = 10000;
                    }
                    cycleBonus += bonus;
                    steps.push(`第${currentStage}关特殊奖励：+${bonus}`);
                }
            }
            total += cycleBonus;


       // 新增：第6关特殊奖励
    if (start <= 6 && end >= 6) {
        total += 100;
        steps.push("第6关特殊奖励：+100");
    }

    // 重构后的额外奖励计算逻辑
    let extraTotal = 0;

    // 生成检测点（包含所有需要计算的关卡）
    const generateCheckpoints = (start, end) => {
        const checkpoints = new Set();
        
        // 标准10倍数关卡
        for (let m = Math.ceil(start/10)*10; m <= end; m +=10) {
            checkpoints.add(m);
        }
        
        // 特殊阶段关键点
        [4662, 4690, 5740].forEach(m => {
            if (m >= start && m <= end) checkpoints.add(m);
        });
        
        // 5740后特殊检测点
        for (let m = 5740; m <= end; m +=30) {
            if (m > 5740) checkpoints.add(m); // 5740+每30关
        }
        for (let m = 5740 + 150; m <= end; m +=150) {
            checkpoints.add(m); // 5740后每150关
        }
        
        return Array.from(checkpoints).sort((a,b) => a - b);
    };

    // 阶段基准值定义
    const stageValues = {
        250: 340,        // 250关累积值 = 100 + 24 * 10
        260: 400,        // 250-260: 340 + 1 * 60
        2400: 21800,     // 260-2400: 400 + 214 * 100
        3000: 24800,     // 2400-3000: 21800 + 30 * 100
        4650: 30300,     // 3000-4650: 24800 + 55 * 100
        4662: 30400,     // 4650后12关
        4690: 30500,     // 4662后28关
        5740: 34000      // 4690-5740: 30500 + 35 * 100
    };

    generateCheckpoints(start, end).forEach(m => {
        let extra = 0;
        let desc = `第${m}关额外奖励：`;
        
        if (m <= 250) {
            // 10-250关：每10关+10
            const term = Math.floor(m/10) - 1;
            extra = 100 + term * 10;
            desc += `基础100 + ${term}次10加成`;
        } 
        else if (m <= 260) {
            // 250-260关：每10关+60
            const cycles = (m - 250)/10;
            extra = stageValues[250] + cycles * 60;
            desc += `250基准340 + ${cycles}次60加成`;
        }
        else if (m <= 2400) {
            // 260-2400关：每10关+100
            const cycles = (m - 260)/10;
            extra = stageValues[260] + cycles * 100;
            desc += `260基准400 + ${cycles}次100加成`;
        }
        else if (m <= 3000) {
            // 2400-3000关：每20关+100
            if (m%20 === 0) {
                const cycles = (m - 2400)/20;
                extra = stageValues[2400] + cycles * 100;
                desc += `2400基准21800 + ${cycles}次100加成`;
            }
        }
        else if (m <= 4650) {
            // 3000-4650关：每30关+100
            if (m%30 === 0) {
                const cycles = (m - 3000)/30;
                extra = stageValues[3000] + cycles * 100;
                desc += `3000基准24800 + ${cycles}次100加成`;
            }
        }
        else if (m === 4662) {
            // 4650-4663特殊处理
            extra = stageValues[4650] + 100;
            desc += "4650后12关加成";
        }
        else if (m === 4690) {
            // 4663-4690特殊处理
            extra = stageValues[4662] + 100;
            desc += "4662后28关加成";
        }
        else if (m <= 5740) {
            // 4690-5740关：每30关+100
            if ((m - 4690)%30 === 0) {
                const cycles = (m - 4690)/30;
                extra = stageValues[4690] + cycles * 100;
                desc += `4690基准30500 + ${cycles}次100加成`;
            }
        }
        else if (m > 5740) {
    // 5740后特殊处理逻辑
    const post5740 = m - 5740;
    const cycle150 = Math.floor(post5740 / 150);  // 计算完整150关周期数
    const base = 34000 + cycle150 * 100;          // 当前周期基准值
    
    // 在150周期内检测30倍数关卡
    if (post5740 % 30 === 0) {
        // 判断是否到达新周期
        if (post5740 % 150 === 0) {
            // 150倍数关卡获得新基准值
            extra = base;
            desc = `${34000}（基准） + ${cycle150}×150关加成 = ${base}`;
        } else {
            // 普通30倍数关卡维持当前周期基准值
            extra = base;
            const currentCycle = cycle150 + 1;
            const progress = post5740 % 150;
            desc = `第${currentCycle}个150周期（进度${progress}关）维持${base}`;
        }
    }
}

        if (extra > 0) {
            extraTotal += extra;
            steps.push(`${desc} = ${extra}`);
        }
    });

    total += extraTotal;

        // 显示结果
        document.getElementById('result').style.display = 'block';
        document.getElementById('total-jade').textContent = total;
        
        // 显示计算步骤
        const stepsContainer = document.getElementById('steps');
        stepsContainer.innerHTML = steps.map(step => `
            <div style="margin: 10px 0; padding: 8px; background: #f8f9fa; border-radius: 4px;">
                ${step}
            </div>
        `).join('');
    }
</script>
</body>
</html>